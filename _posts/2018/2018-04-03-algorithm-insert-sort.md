---
layout: post
title: 算法-插入排序
categories: [算法]
description: "有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法——插入排序法,插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。"
keywords: 插入排序, Java
tags: [插入排序, Java]
excerpt: "有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法——插入排序法,插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。"
---
1. 算法可视化: [连接][href1]
1. 时间复杂度，平均：$$O(n^2)$$，最坏：$$O(n^2)$$，最好：$$O(n)$$
1. 空间复杂度，$$O(1)$$
1. 是否稳定：稳定
1. 本文图片来源：[https://www.cnblogs.com/xiaoming0601/p/5862793.html][href2] 

## 算法思想
通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应的位置并插入。
类似于扑克牌排序：

[![insert-sort][img1]][img1]{:data-lightbox="sort"}

1. 刚开始摸牌的时候左手是空的，接着一次从桌上摸一张牌，并将它插入到牌中的「正确」位置。
1. 算法的核心步骤就是寻找「正确」位置。
   * 手中的牌是有序的，然后摸起一张牌 M。
   * 扫描手中的牌与 M 进行一一对比，找到插入的位置。
   * 将 M 插入找到的位置即可。
   * 为了提升效率，M 插入的时候牵涉到数组移动，所以可以一边对比一边移动，找到位置直接插入即可

```java
/**
 * 插入排序
 *
 * @author ychost
 * @date 2018-4-3
 */
public class InsertSort {
    void sort(int[] data) {
        for (int i = 1; i < data.length; i++) {
            int cur = data[i];
            int j = i;
            //找到插入位置
            for (; j > 0; j--) {
                //一边比较一边移位
                if (cur < data[j - 1]) {
                    data[j] = data[j - 1];
                } else {
                    break;
                }
            }
            data[j] = cur;
        }
    }
}
```


[img1]: /images/post/algorithm/insert-sort.png

[href1]:  https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html
[href2]: https://www.cnblogs.com/xiaoming0601/p/5862793.html
